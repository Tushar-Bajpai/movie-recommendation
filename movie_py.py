# -*- coding: utf-8 -*-
"""movie.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cO9MjrV2WQQLgRZoY_01pa7ka8ulI8hx
"""

!pip install pandas numpy scikit-learn
!pip install nltk spacy
!pip install requests beautifulsoup4
!pip install matplotlib seaborn
!pip install surprise lightfm

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

data = pd.read_csv('/content/tmdb_5000_movies.csv')

data

data.head()

data['combined_features'] = data['genres'] + " " + data['release_date'] + " " + data['keywords'] + " " + data['title'] + " " + data['overview']

data.head()

print(data['combined_features'].isnull().sum())

data['combined_features'] = data['combined_features'].fillna('')

from sklearn.feature_extraction.text import TfidfVectorizer

vectorizer = TfidfVectorizer()
feature_vectors = vectorizer.fit_transform(data['combined_features'])
print(feature_vectors.shape)  # Prints the shape of the resulting matrix

similarity_matrix = cosine_similarity(feature_vectors)

from sklearn.metrics.pairwise import cosine_similarity

def recommend(movie_name):
    # Check if the movie exists in the dataset
    if movie_name not in data['name'].values:
        return "Movie not found in the dataset."

    # Get the index of the movie
    movie_index = data[data['name'] == movie_name].index[0]

    # Compute similarity scores for the selected movie
    similarity_scores = cosine_similarity(feature_vectors[movie_index], feature_vectors)

    # Enumerate similarity scores and sort them in descending order
    similar_movies = list(enumerate(similarity_scores[0]))
    sorted_movies = sorted(similar_movies, key=lambda x: x[1], reverse=True)

    # Get the top 5 similar movies (excluding the input movie itself)
    top_movies = [data['name'][i[0]] for i in sorted_movies[1:6]]

    return top_movies

print(data.columns)

def recommend(movie_name):
    # Check if the movie exists in the dataset
    if movie_name not in data['original_title'].values:  # Update 'name' to 'original_title'
        return "Movie not found in the dataset."

    # Get the index of the movie
    movie_index = data[data['original_title'] == movie_name].index[0]  # Update 'name' to 'original_title'

    # Compute similarity scores for the selected movie
    similarity_scores = cosine_similarity(feature_vectors[movie_index], feature_vectors)

    # Enumerate similarity scores and sort them in descending order
    similar_movies = list(enumerate(similarity_scores[0]))
    sorted_movies = sorted(similar_movies, key=lambda x: x[1], reverse=True)

    # Get the top 5 similar movies (excluding the input movie itself)
    top_movies = [data['original_title'][i[0]] for i in sorted_movies[1:6]]  # Update 'name' to 'original_title+original_title'

    return top_movies

data.columns = data.columns.str.lower()

print(recommend('titanic'))  # Replace 'Spider Man' with a valid movie in your dataset

data.head(30)

# Import required libraries
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load your dataset
data = pd.read_csv('/content/tmdb_5000_movies.csv')  # Replace with the path to your dataset

# Combine the movie original_title and genre into one feature
data['combined_features'] = data['genres'] + " " + data['original_title']

# Fill any missing values in the 'combined_features' column
data['combined_features'] = data['combined_features'].fillna('')

# Initialize the TF-IDF Vectorizer
vectorizer = TfidfVectorizer(stop_words='english')

# Transform the combined features into numerical values using TF-IDF
feature_vectors = vectorizer.fit_transform(data['combined_features'])

# Compute the cosine similarity matrix
similarity_matrix = cosine_similarity(feature_vectors)

# Function to recommend movies based on the movie name and original_title
def recommend(movie_name, top_n=5):
    try:

        # Find the index of the movie
        movie_index = data[data['original_title'] == movie_name].index[0]

        # Get the similarity scores for this movie
        similarity_scores = list(enumerate(similarity_matrix[movie_index]))

        # Sort the movies based on similarity scores (descending order)
        sorted_movies = sorted(similarity_scores, key=lambda x: x[1], reverse=True)

        # Get the top N similar movies (excluding the input movie itself)
        recommended_movies = [data['original_title'][i[0]] for i in sorted_movies[1:top_n+1]]

        return recommended_movies
    except IndexError:
        return "Movie not found in the dataset."

# Test the recommendation function
test_movie = "Jurassic World"  # Replace with an existing movie name from your dataset
recommendations = recommend(test_movie)
print(f"Recommended movies based on '{test_movie}':")
print(recommendations)

import pandas as pd
import re

# Load your dataset (replace with your actual dataset path)
data = pd.read_csv('/content/tmdb_5000_movies.csv')

# Normalize the movie titles and genres
data['title_normalized'] = data['original_title'].str.lower().apply(lambda x: re.sub(r'[^\w\s]', '', x))
data['genres_normalized'] = data['genres'].str.lower()

# Function to recommend movies based on movie name and genre
def recommend_based_on_name_and_genre(movie_name, top_n=5):
    try:
        # Normalize the input movie name
        movie_name_normalized = re.sub(r'[^\w\s]', '', movie_name.lower())

        # Find the movie index based on normalized title
        movie_index = data[data['title_normalized'] == movie_name_normalized].index[0]

        # Get the genre of the movie
        movie_genre = data['genres_normalized'][movie_index]

        # Filter movies that share the same genre
        genre_movies = data[data['genres_normalized'] == movie_genre]

        # Exclude the input movie itself from the results
        genre_movies = genre_movies[genre_movies['title_normalized'] != movie_name_normalized]

        # Sort the filtered movies by title (or you can sort by rating/popularity if available)
        recommended_movies = genre_movies['original_title'].head(top_n).tolist()

        return recommended_movies
    except IndexError:
        return "Movie not found in the dataset."

# Test the recommendation function
test_movie = "spectre"  # You can test with different movie names
recommendations = recommend_based_on_name_and_genre(test_movie)
print(f"Recommended movies based on '{test_movie}' name and genre:")
print(recommendations)

import matplotlib.pyplot as plt
import seaborn as sns

sns.heatmap(similarity_matrix, cmap="coolwarm")
plt.show()

!pip install streamlit

import streamlit as st
import pandas as pd
import re

# Load your dataset
data = pd.read_csv('/content/tmdb_5000_movies.csv')

# Normalize the movie titles and genres
data['title_normalized'] = data['original_title'].str.lower().apply(lambda x: re.sub(r'[^\w\s]', '', x))
data['genres_normalized'] = data['genres'].str.lower()

# Function to recommend movies based on name and genre
def recommend_based_on_name_and_genre(movie_name, top_n=5):
    try:
        movie_name_normalized = re.sub(r'[^\w\s]', '', movie_name.lower())
        movie_index = data[data['title_normalized'] == movie_name_normalized].index[0]
        movie_genre = data['genres_normalized'][movie_index]
        genre_movies = data[data['genres_normalized'] == movie_genre]
        genre_movies = genre_movies[genre_movies['title_normalized'] != movie_name_normalized]
        recommended_movies = genre_movies['original_title'].head(top_n).tolist()
        return recommended_movies
    except IndexError:
        return ["Movie not found in the dataset."]

# Streamlit interface
st.title("Movie Recommendation System")

# Input for movie name
movie_name = st.text_input("Enter a movie name:")

# Button to get recommendations
if st.button("Get Recommendations"):
    if movie_name:
        recommendations = recommend_based_on_name_and_genre(movie_name)
        st.write(f"Recommendations for '{movie_name}':")
        for movie in recommendations:
            st.write(f"- {movie}")
    else:
        st.write("Please enter a movie name.")

import streamlit as st
import pandas as pd
import re
import requests

# Load your dataset (make sure it's available in Colab or in your GitHub repository)
data = pd.read_csv('/content/tmdb_5000_movies.csv')

# Preprocess the dataset (normalize titles, genres)
data['title_normalized'] = data['original_title'].str.lower()
data['genres_normalized'] = data['genres'].str.lower()

# Recommendation function
def recommend_based_on_name_and_genre(movie_name, top_n=5):
    try:
        movie_name_normalized = re.sub(r'[^\w\s]', '', movie_name.lower())
        movie_index = data[data['title_normalized'] == movie_name_normalized].index[0]
        movie_genre = data['genres_normalized'][movie_index]
        genre_movies = data[data['genres_normalized'] == movie_genre]
        genre_movies = genre_movies[genre_movies['title_normalized'] != movie_name_normalized]
        recommended_movies = genre_movies.head(top_n)
        return recommended_movies
    except IndexError:
        return []

# Streamlit UI
st.title("Movie Recommendation System")

st.markdown("""
    <style>
    body {
        background-color: #f0f0f0;
        color: black;
    }
    .stButton>button {
        background-color: #FF5733;
        color: white;
        border-radius: 8px;
        padding: 12px;
    }
    </style>
""", unsafe_allow_html=True)

# Input for movie name
movie_name = st.text_input("Enter a movie name:")

# Button to get recommendations
if st.button("Get Recommendations"):
    if movie_name:
        recommendations = recommend_based_on_name_and_genre(movie_name)
        if recommendations:
            st.write(f"Recommendations for '{movie_name}':")
            for index, movie in recommendations.iterrows():
                st.write(f"- {movie['original_title']}")
        else:
            st.write("Movie not found in the dataset.")
    else:
        st.write("Please enter a movie name.")

!pip install streamlit

!streamlit run movie.py

